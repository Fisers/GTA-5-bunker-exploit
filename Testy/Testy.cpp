#include "pch.h"
#include <iostream>
#include "windows.h"
#include <string> 
#include <stdlib.h> 
#include "tlhelp32.h" 
#include <vector>
#include "vector.h"
#include <limits>
#include <stdexcept>

using namespace std;

DWORD pid;
DWORD64 Base;

DWORD64 GlobalPTR;
DWORD64 RPPTR;
DWORD64 WorldPTR;

#pragma region usefullstuff

uintptr_t GetModuleBaseAddress(DWORD procId, const wchar_t* modName)
{
	uintptr_t modBaseAddr = 0;
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procId);
	if (hSnap != INVALID_HANDLE_VALUE)
	{
		MODULEENTRY32 modEntry;
		modEntry.dwSize = sizeof(modEntry);
		if (Module32First(hSnap, &modEntry))
		{
			do
			{
				if (!_wcsicmp(modEntry.szModule, modName))
				{
					modBaseAddr = (uintptr_t)modEntry.modBaseAddr;
					break;
				}
			} while (Module32Next(hSnap, &modEntry));
		}
	}
	CloseHandle(hSnap);
	return modBaseAddr;
}

uintptr_t FindPointer(HANDLE hproc, uintptr_t ptr, std::vector<unsigned int> offsets)
{
	uintptr_t addr = ptr;
	for (unsigned int i = 0; i < offsets.size(); i++)
	{
		ReadProcessMemory(hproc, (BYTE*)addr, &addr, sizeof(addr), 0);
		addr += offsets[i];
	}
	return addr;
}

uintptr_t GetPID(const wchar_t* procName) {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);
	uintptr_t pID = NULL;
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (Process32First(snapshot, &entry)) {
		do {
			if (_wcsicmp(entry.szExeFile, procName) == 0) {																	
				pID = entry.th32ProcessID;
				break;
			}
		} while (Process32Next(snapshot, &entry));
	}
	CloseHandle(snapshot);
	return pID;
}

uintptr_t GetModuleSize(DWORD pID, const wchar_t*moduleName) {

	MODULEENTRY32 entry;
	entry.dwSize = sizeof(MODULEENTRY32);
	uintptr_t moduleSize = 0;

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pID);

	if (Module32First(snapshot, &entry)) {
		do {
			if (_wcsicmp(entry.szModule, moduleName) == 0) {
				moduleSize = (uintptr_t)entry.modBaseSize;
				break;
			}
		} while (Module32Next(snapshot, &entry));
	}

	CloseHandle(snapshot);
	return moduleSize;
}

INT64 readPointer(HANDLE hproc, DWORD64 Address)
{
	INT64 value;
	ReadProcessMemory(hproc, (INT64*)Address, &value, sizeof(value),0);
	return value;
}

int readInteger(HANDLE hproc, DWORD64 Address)
{
	int value;
	ReadProcessMemory(hproc, (BYTE*)Address, &value, sizeof(value), 0);
	return value;
}

using std::cout;
using std::endl;
using std::string;

struct module
{
	DWORD64 dwBase, dwSize;
};

module TargetModule;
HANDLE TargetProcess;
DWORD64  TargetId;

HANDLE GetProcess(const wchar_t* processName)
{
	HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(entry);

	do
		if (!_wcsicmp(entry.szExeFile, processName)) {
			TargetId = entry.th32ProcessID;
			CloseHandle(handle);
			TargetProcess = OpenProcess(PROCESS_ALL_ACCESS, false, TargetId);
			return TargetProcess;
		}
	while (Process32Next(handle, &entry));

	return false;
}

module GetModule(const wchar_t* moduleName) {
	HANDLE hmodule = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, TargetId);
	MODULEENTRY32 mEntry;
	mEntry.dwSize = sizeof(mEntry);

	do {
		if (!_wcsicmp(mEntry.szModule, (const wchar_t*)moduleName)) {
			CloseHandle(hmodule);

			TargetModule = { (DWORD64)mEntry.hModule, mEntry.modBaseSize };
			return TargetModule;
		}
	} while (Module32Next(hmodule, &mEntry));

	module mod = { (DWORD64)false, (DWORD64)false };
	return mod;
}

template <typename var>
bool WriteMemory(DWORD64 Address, var Value) {
	return WriteProcessMemory(TargetProcess, (LPVOID)Address, &Value, sizeof(var), 0);
}

template <typename var>
var ReadMemory(DWORD64 Address) {
	var value;
	ReadProcessMemory(TargetProcess, (LPCVOID)Address, &value, sizeof(var), NULL);
	return value;
}

bool MemoryCompare(const BYTE* bData, const BYTE* bMask, const char* szMask) {
	for (; *szMask; ++szMask, ++bData, ++bMask) {
		if (*szMask == 'x' && *bData != *bMask) {
			return false;
		}
	}
	return (*szMask == NULL);
}

DWORD64 FindSignature(DWORD64 start, DWORD64 size, const char* sig, const char* mask)
{
	BYTE* data = new BYTE[size];
	SIZE_T bytesRead;

	ReadProcessMemory(TargetProcess, (LPVOID)start, data, size, &bytesRead);

	for (DWORD64 i = 0; i < size; i++)
	{
		if (MemoryCompare((const BYTE*)(data + i), (const BYTE*)sig, mask)) {
			return start + i;
		}
	}
	delete[] data;
	return NULL;
}

#pragma endregion

int main()
{
	SetConsoleTitle(L"GTA V cheat by Kwasiks (Onra2's base)");
	HWND hWnd = FindWindowA(0, "Grand Theft Auto V");
	GetWindowThreadProcessId(hWnd, &pid);
	HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	Base = GetModuleBaseAddress(pid, L"GTA5.exe");

	/*========================================================================================*/

	LPCSTR SignatureGlobalPTR = "\x4c\x8d\x05\x00\x00\x00\x00\x4d\x8b\x08\x4d\x85\xc9\x74\x11";
	LPCSTR MaskGlobalPTR = "xxx????xxxxxxxx";
	
	LPCSTR GetPointerAddressA = "\x4d\x89\xb4\xf7\x00\x00\x00\x00\x48\x8b\x74\x24";
	LPCSTR MaskPointer = "xxxx????xxxx";

	LPCSTR SignatureWorldPTR = "\x48\x8b\x05\x00\x00\x00\x00\x45\x00\x00\x00\x00\x48\x8b\x48\x08\x48\x85\xc9\x74\x07";
	LPCSTR MaskWorldPTR = "xxx????x????xxxxxxxxx";

	if (GetProcess(L"GTA5.exe"))
	{
		module mod = GetModule(L"GTA5.exe");

		DWORD64 TempGlobalPTR = FindSignature(mod.dwBase, mod.dwSize, SignatureGlobalPTR, MaskGlobalPTR);
		GlobalPTR = TempGlobalPTR + readInteger(pHandle, TempGlobalPTR + 3) + 7;

		DWORD64 TempWorldPTR = FindSignature(mod.dwBase, mod.dwSize, SignatureWorldPTR, MaskWorldPTR);
		WorldPTR = TempWorldPTR + readInteger(pHandle, TempWorldPTR + 3) + 7;
		
		DWORD64 TempRPPTR = FindSignature(mod.dwBase, mod.dwSize, GetPointerAddressA, MaskPointer);
		RPPTR = TempRPPTR + 4;
		RPPTR = readInteger(pHandle, RPPTR);
		RPPTR = RPPTR + mod.dwBase + 0x8;

	}
	
	std::cout << "-- GTA 5 bunker delivery mod by Kwasiks --" << std::endl;
	std::cout << "F1 - Ieslegt naudas haku!" << std::endl;
	std::cout << "F2 - RP reizinatajs!" << std::endl;
	std::cout << "F3 - Level Exploit!" << std::endl;
	std::cout << "" << std::endl;

	uintptr_t dynamicPtrBaseAddr = (GlobalPTR - 0x128);
	uintptr_t WorldPtrBaseAddr = (WorldPTR);

	std::vector<unsigned int> OffsetsDelivery = { 0x1180, 0x41B8 };
	std::vector<unsigned int> OffsetsWantedLevel = { 0x08, 0x10B8, 0x0848 };
	std::vector<unsigned int> RPMultOffset = {0x10};

	/*========================================================================================*/
	uintptr_t DeliveryAddress = FindPointer(pHandle, dynamicPtrBaseAddr, OffsetsDelivery);
	uintptr_t RPAddress = FindPointer(pHandle, RPPTR, RPMultOffset);
	uintptr_t WantedAddress = FindPointer(pHandle, WorldPtrBaseAddr, OffsetsWantedLevel);
	/*========================================================================================*/

	bool bTwoBillion = false;
	bool bWanted = false;
	while (TRUE)
	{
		Sleep(1);
		if (GetAsyncKeyState(VK_F1) & 1)
		{
			bTwoBillion = !bTwoBillion;
			if (bTwoBillion)
			{
				cout << "Tutorial: Jaieraksta numurs ar kuru velies reizinat." << endl;
				cout << "Piemers: Tavs weapon stock value ir 7000$, kad sac misiju, ja radas, ka vajag deliver 5 ierocus." << endl;
				cout << "Tev vajag sadalit 7000$ ar 5 = 1400$. Tagad sadali summu ko velies iegut ar sho ciparu." << endl;
				cout << "Piemers: 2 000 000 / 1400 = 1430. Sho ieguto numuru raksti sheit ieksha." << endl;

				int i;
				cout << "Ieraksti reizinataju: ";
				cin >> i;
				
				WriteProcessMemory(pHandle, (BYTE*)DeliveryAddress, &i, sizeof(i), 0);

				int DeliveryCount;
				ReadProcessMemory(pHandle, (BYTE*)DeliveryAddress, &DeliveryCount, sizeof(DeliveryCount), nullptr);
				std::cout << "Bunker Delivery count = " << std::dec << DeliveryCount << std::endl;
				std::cout << "Naudas haks: aktiivs" << std::endl;
			}
			else
			{
				std::cout << "Naudas haks: neaktiivs" << std::endl;
				int TwoBillion = 0;
				WriteProcessMemory(pHandle, (BYTE*)DeliveryAddress, &TwoBillion, sizeof(TwoBillion), 0);
			}
		}
		if (GetAsyncKeyState(VK_F2) & 1)
		{
			float i;
			cout << "Ieraksti RP reizinataju: ";
			cin >> i;

			WriteProcessMemory(pHandle, (float*)RPAddress, &i, sizeof(i), 0);

			float DeliveryCount;
			ReadProcessMemory(pHandle, (float*)RPAddress, &DeliveryCount, sizeof(DeliveryCount), nullptr);
			std::cout << "Rp reizinatajs = " << std::dec << DeliveryCount << std::endl;
		}
		if (GetAsyncKeyState(VK_F3) & 1)
		{
			int Wanted = 1;
			WriteProcessMemory(pHandle, (BYTE*)WantedAddress, &Wanted, sizeof(Wanted), 0);
			Sleep(100);
			Wanted = 0;
			WriteProcessMemory(pHandle, (BYTE*)WantedAddress, &Wanted, sizeof(Wanted), 0);
			Sleep(100);
		}
	}
}